1/13 - 1/20:

First, I went and found a video to test all of my code on. "test-tube.mp4" (https://pixabay.com/videos/test-tubes-experiment-science-lab-5451/)
I also downloaded the Lenna.png image off of Google, since Lenna is commonly used as a test image in Computer Science.
I set up Project.py, wrote a brightness function that return the average intensity of each pixel, and wrote an encode and decode function.
In the encode function, it went through each frame and visited a specific pixel to get the brightness. If the binary message bit was a 0, 
and the brightness was even, nothing happened. If bit was 0 and brightness odd, brightness += 1. If bit = 1 and brightness = even, brightness += 1. 
I did this twice, saved once as .mp4 and again as .avi. However this did not work because of the compression / encoding used in the video formats.

1/20 - 1/23:
Made brightnessTest.py to keep track of different functions I would be cycling in and out of Project.py

Diff way of encoding:
Choose a specific group(10x10)of pixels in each frame to make either all white, or all black:
    all white = 0
    all black = 1

To Decode:
    Have the method to find the same group of pixels:
      if white, write 0
      if black, write 1  

This method ended up working well. Although I had to be a little more vague with the decoding, if every pixel had each color value > 200, I counted that as white.
Then, anything less than that would be considered black and marked as a 1. I think this works. Now I want to see how far down I can scale this.

Since that worked, I put a 6 long line in the middle of the video. Same as ebfore, white pixel = 0, black pixel = 1. The message was still there,
but a little damaged. 

01110100011010000110010101110010011001010010000001101001011100110010000001101001001000000111001101100101011000110111101001100101011101000010000001101000011001010111001001100101 
"there is i seczet here"

I made compare.py and compared the pixel values of the first frame of the video to the encoded video. The pixels were only changed within 5%. 
Some 7%.

I swapped ways to get brightness. Same results.

I recorded the changes in brightness between the normal video and encoded video. I split the videos into 16x16 blocks, and took the average
pixel brightness of those blocks. I also got the individual change in brightness of every pixel as an aside. I went and saved graphs of these
excel sheets as SVGs. Tbh there looks like there are some spots to use rather than others, but for the most part they all seem to have changed
a similar amount. 

The changes in brightness showed that they only changed by a max of 3. So I tried to make the encoding based on even / odd multiples greater than 3.
This did not work very well for messages since they were still changed. 

-------
On even blocks, use four. On odd blocks, use five. 
If the bit is a 1, change the brightness to the nearest odd multiple of 4 or 5 
If the bit is 0, change the brightness to the nearest even multiple of 4 or 5

To encode, check if brightness/N is a multiple. If not we can assume it is the closest one. So if N is like 13 and brightness is like 16
we will say it is probably 13 and not 26. That means that the multiple is odd and there is a 1 stored there. If the multiple is even, there is a o.

This did not work well. I encoded the message in every block until I ran out of blocks in a frame, then split that really big string of 1 and 0s
according to the length of the original binary message. That way I could compare which blocks yielded the more accurateness. It seemed random, but for this
video I figured out the 704th block was accurate up to 8 bits. So I have a new idea:

The message is 32 bits long. I will split into sections of 4. Then, for four frames, I will encode exclusively around that block. I think it might be
accurate around those areas so long as the frames dont change too much. 

This did not work. This actually somehow worked worse. Will check by later why it did not work. 

